# Project1: Threads

이 과제에서는 기능이 제한된 스레드 시스템을 제공합니다. 여러분의 역할은 이 시스템의 기능을 확장하여 동기화 문제에 대한 이해를 높이는 것입니다. 이 과제에서는 주로 threads 디렉토리에서 작업을 수행하며, 일부 작업은 devices 디렉토리에서도 진행됩니다. 컴파일은 threads 디렉토리에서 수행해야 합니다. 이 프로젝트에 대한 설명을 읽기 전에 동기화(Synchronization) 자료를 최소한 훑어보는 것이 좋습니다.

## Background

### Understanding Threads

첫 번째 단계는 초기 스레드 시스템의 코드를 읽고 이해하는 것입니다. Pintos는 이미 스레드 생성 및 스레드 완료, 스레드 간 전환을 위한 간단한 스케줄러, 그리고 동기화 기본 요소(세마포어, 잠금, 조건 변수, 최적화 장벽)를 구현하고 있습니다.

이 코드 중 일부는 약간 신비로울 수 있습니다. 이미 기본 시스템을 컴파일하고 실행하지 않았다면, 소개에서 설명한 대로 지금 실행해보세요. 소스 코드의 일부분을 읽어보면 어떤 일이 벌어지는지 알 수 있습니다. 원한다면 거의 어디에서든 printf() 호출을 추가하고, 다시 컴파일하고 실행하여 어떤 일이 어떤 순서로 일어나는지 확인할 수 있습니다. 또한 디버거에서 커널을 실행하고 흥미로운 위치에 중단점을 설정하고 코드를 단계별로 진행하며 데이터를 검사할 수도 있습니다.

스레드가 생성되면, 스케줄링될 새로운 컨텍스트가 생성됩니다. thread_create()에 전달되는 함수가 이 컨텍스트에서 실행될 함수로 제공됩니다. 스레드가 처음 스케줄링되어 실행될 때, 해당 함수의 시작부터 실행되며 해당 컨텍스트에서 작동합니다. 함수가 반환되면 스레드가 종료됩니다. 따라서 각 스레드는 Pintos 내에서 실행되는 미니 프로그램처럼 작동하며, thread_create()에 전달된 함수가 main() 함수처럼 작동합니다.

특정 시점에서 정확히 하나의 스레드가 실행되며, 나머지 스레드는 비활성화됩니다. 스케줄러는 다음에 실행할 스레드를 결정합니다. (특정 시점에 실행할 준비된 스레드가 없으면, idle() 함수에 구현된 특수한 idle 스레드가 실행됩니다.) 동기화 기본 요소는 한 스레드가 다른 스레드가 어떤 작업을 수행할 때까지 기다려야 할 때 컨텍스트 전환을 강제할 수 있습니다.

컨텍스트 전환의 메커니즘은 threads/thread.c의 thread_launch()에 있습니다. (이를 이해할 필요는 없습니다.) 이 함수는 현재 실행 중인 스레드의 상태를 저장하고, 전환할 스레드의 상태를 복원합니다.

GDB 디버거를 사용하여 컨텍스트 전환을 천천히 추적하여 무슨 일이 일어나는지 살펴보세요 (GDB 참조). schedule()에 중단점을 설정하고 거기서부터 단계별로 진행해보세요. 각 스레드의 주소와 상태, 각 스레드의 호출 스택에 있는 프로시저를 추적하는 것을 잊지 마세요. do_iret()에서 iret을 실행하는 동안 다른 스레드가 실행되기 시작하는 것을 알 수 있을 것입니다.

주의: Pintos에서는 각 스레드마다 약 4 kB 크기의 작은 고정 크기 실행 스택이 할당됩니다. 커널은 스택 오버플로우를 감지하려고 시도하지만, 완벽하게 감지할 수는 없습니다. 예를 들어, int buf[1000];와 같은 큰 데이터 구조를 비정적 지역 변수로 선언하면 이상한 문제(예: 알 수 없는 커널 패닉)가 발생할 수 있습니다. 스택 할당을 대체할 수 있는 방법으로는 페이지 할당기와 블록 할당기가 있습니다 (Memory Allocation 참조).

## Synchronization

적절한 동기화는 이러한 문제의 해결에 중요한 부분입니다. 동기화 문제는 인터럽트를 비활성화하는 방식으로 쉽게 해결할 수 있습니다. 인터럽트가 비활성화된 상태에서는 동시성이 없으므로 경합 조건이 발생할 가능성이 없습니다. 따라서 모든 동기화 문제를 이 방법으로 해결하는 것이 유혹스러울 수 있지만, 그렇게 하지 마세요. 대신 세마포어, 잠금, 조건 변수를 사용하여 대부분의 동기화 문제를 해결하세요. 동기화 기본 요소를 사용하는 상황에 대해 확실하지 않다면 동기화에 관한 가이드 섹션(Synchronization 참조)이나 threads/synch.c의 주석을 읽어보세요.

Pintos 프로젝트에서 인터럽트를 비활성화하는 것이 가장 적합한 문제 해결 방법은 커널 스레드와 인터럽트 핸들러 사이에서 데이터를 조정하는 것입니다. 인터럽트 핸들러는 슬립할 수 없으므로 잠금을 획득할 수 없습니다. 따라서 커널 스레드와 인터럽트 핸들러 사이에서 공유되는 데이터는 인터럽트를 비활성화하여 커널 스레드 내에서 보호해야 합니다.

이 프로젝트에서는 인터럽트 핸들러에서 약간의 스레드 상태에 접근해야 합니다. 알람 시계의 경우, 타이머 인터럽트는 슬립 중인 스레드를 깨워야 합니다. 고급 스케줄러에서는 타이머 인터럽트가 몇 개의 전역 및 스레드별 변수에 액세스해야 합니다. 이러한 변수를 커널 스레드에서 액세스할 때는 인터럽트를 비활성화하여 타이머 인터럽트가 간섭하지 않도록 해야 합니다.

인터럽트를 비활성화할 때는 최소한의 코드에 대해서만 그렇게 해야 합니다. 그렇지 않으면 타이머 틱이나 입력 이벤트와 같은 중요한 것을 잃어버릴 수 있습니다. 또한 인터럽트를 비활성화하면 인터럽트 처리 지연이 증가하여 너무 많이 사용하면 시스템이 느려질 수 있습니다.

synch.c의 동기화 기본 요소 자체는 인터럽트를 비활성화하여 구

현됩니다. 여기에서 인터럽트가 비활성화된 상태에서 실행되는 코드 양을 늘려야 할 수도 있지만, 최소한으로 유지하려고 노력해야 합니다.

디버깅을 위해 인터럽트를 비활성화하는 것은 유용할 수 있습니다. 특정 코드 영역이 인터럽트에 방해받지 않는지 확인하려는 경우에 사용할 수 있습니다. 그러나 프로젝트를 제출하기 전에 디버깅 코드를 제거해야 합니다. (주석 처리하는 것만으로는 코드가 읽기 어려워질 수 있습니다.)

제출한 코드에는 바쁜 대기(busy waiting)가 없어야 합니다. thread_yield()를 호출하는 루프는 바쁜 대기의 한 형태입니다.

## Development Suggestions

과거에는 많은 그룹들이 과제를 조각내어 각 그룹원이 자신의 부분에 작업하다가 마감 직전에 코드를 결합하고 제출하는 방식을 사용했습니다. 이는 좋은 방법이 아닙니다. 이러한 방식을 선택한 그룹은 종종 두 가지 변경 사항이 충돌하여 많은 마지막 순간 디버깅을 필요로 한다는 것을 발견합니다. 이렇게 진행한 일부 그룹은 컴파일 또는 부트를 할 수도 없는 코드를 제출한 경우도 있습니다.

대신, git과 같은 소스 코드 관리 시스템을 사용하여 팀의 변경 사항을 조기에 자주 통합하는 것을 권장합니다. 이렇게 하면 모든 사람이 코드를 완성할 때가 아니라 코드가 작성되는 동안 다른 사람의 코드를 볼 수 있기 때문에 놀라움이 적을 것입니다. 이러한 시스템을 사용하면 변경 사항을 검토하고, 변경 사항이 버그를 도입한 경우 이전 버전의 코드로 돌아갈 수도 있습니다.

이 프로젝트와 후속 프로젝트를 수행하는 동안 이해할 수 없는 버그에 직면할 것으로 예상해야 합니다. 이럴 때는 디버깅 도구에 대한 부록을 다시 읽어보세요. 유용한 디버깅 팁이 많이 포함되어 있어 속도를 빠르게 회복하는 데 도움이 될 것입니다 (디버깅 도구 참조). 특히 백트레이스(Backtraces) 섹션을 읽어보세요. 이는 커널 패닉 또는 어서션 실패를 최대한 활용하는 데 도움이 될 것입니다.
